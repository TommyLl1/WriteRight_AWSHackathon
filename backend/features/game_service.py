from typing import Optional, List, Union
from uuid import UUID
from models.db.db import *
from utils.database.base import DatabaseService
from models.QnA import QuestionBase, AnswerType
import asyncio
from features.user_service import UserService
from models.helpers import to_unicodeInt_from_char
from models.db.db import FlaggedQuestionStatus
from pydantic import BaseModel
from features.word_service import WordService
from utils.logger import setup_logger

logger = setup_logger(__name__)


# Interfaces between functions only
class CheckedQA(BaseModel):
    question_id: UUIDStr
    # Questions might not be answered, so we use Optional
    submitted_answer: Optional[SubmittedAnswer] = None
    target_word: ChineseChar
    is_correct: bool


class MarkingResult(BaseModel):
    checked_questions: List[CheckedQA]
    total_score: int
    remaining_hearts: int


class FlaggedQuestion(BaseModel):
    flag_id: Optional[UUIDStr] = None  # Auto-generated by the database
    question_id: UUIDStr
    user_id: UUIDStr
    flagged_at: int
    reason: Optional[str] = None
    notes: Optional[str] = None
    status: FlaggedQuestionStatus = FlaggedQuestionStatus.PENDING


class GameService:
    """
    Controlls the game start and end.
    """

    def __init__(self, db: DatabaseService, user_service: UserService):
        self.db = db
        self.user_service = user_service

    async def create_game_session(
        self, user_id: UUIDStr, question_ids: List[UUIDStr]
    ) -> UUIDStr:
        """
        Creates a new game session in the database.
        Returns the game session ID. (game_id)
        """
        # logger.debug(
        #     f"Creating game session for user {user_id} with questions {question_ids}"
        # )

        game_session_entry = GameSession(
            user_id=user_id,
            question_ids=question_ids,
        )
        # logger.debug(game_session_entry)
        try:
            # Seems like model_dump() is not working
            # It is indeed working actually``
            game_session = game_session_entry.model_dump()
        except Exception as e:
            logger.error(f"Failed to format game session entry: {str(e)}")
            raise Exception(f"Failed to format game session entry: {str(e)}")
        # logger.debug(f"Game session JSON: {game_session_json}")

        try:
            await self.db.insert_data(SupabaseTable.GAME_SESSIONS, game_session)
            # logger.debug(f"Result: {result}")
            # if not result.data or "game_id" not in result.data:
            #     raise Exception("Failed to create game session, no game_id returned")
            return game_session_entry.game_id
        except Exception as e:
            raise Exception(f"Failed to store game session obj: {str(e)}")

    async def _end_game_session(self, game_id: UUIDStr) -> GameSession:
        """
        Ends the game session and updates the score and duration.
        """
        try:
            # Update and get the game session
            game_session_response = await self.db.update_data(
                SupabaseTable.GAME_SESSIONS,
                {"status": GameSessionStatus.COMPLETED},
                condition={"game_id": game_id},
            )
            if not game_session_response.data:
                raise Exception("Game session not found or update failed")

            # Format the response into a GameSession object
            game_session_data = game_session_response.data[0]
            game_session_object = GameSession.model_validate(game_session_data)
            return game_session_object

        except Exception as e:
            raise Exception(f"Failed to end game session: {str(e)}")

    async def cron_update_game_sessions(self):
        """
        Cron job to update all game sessions that are still in progress.

        > 12 hours: marked as abandoned
        > a week: cleaned up

        DEPRECATED: This function is deprecated and may be removed in future versions. Use the new cleanup mechanism instead.
        """
        import warnings

        warnings.warn(
            "cron_update_game_sessions is deprecated and may be removed in future versions. Use the new cleanup mechanism instead.",
            DeprecationWarning,
            stacklevel=2,
        )
        await self.db.rpc_query(
            SupabaseRPC.CLEAN_GAME_SESSIONS,
            {},
            mode="table",
        )

    async def _save_game_history(
        self,
        marked_result: MarkingResult,
        game_session: GameSession,
    ) -> GameData:
        """
        Saves the game history to the database after checking answers.
        Not answered questions will be skipped.
        """
        current_time = get_time()
        total_score = marked_result.total_score
        checked_questions = marked_result.checked_questions
        remaining_hearts = marked_result.remaining_hearts

        # Validate everything first before saving into db
        # Game Metadata
        game_data = GameData(
            user_id=game_session.user_id,
            game_id=game_session.game_id,
            created_at=current_time,
            time_spent=current_time - game_session.start_time,
            total_score=total_score,
            question_count=len(checked_questions),
            earned_exp=total_score,  # Assuming score is equivalent to earned exp
            remaining_hearts=remaining_hearts,
            correct_count=sum(1 for q in checked_questions if q.is_correct),
        )

        # Validate and format each question's answer
        game_qa_history_entries: list[GameQAHistory] = []
        for idx, question in enumerate(checked_questions):
            if not question.submitted_answer:
                logger.info(
                    f"Question {question.question_id} has no submitted answer, skipping."
                )
                continue  # Skip questions without submitted answers
            game_qa_history = GameQAHistory(
                game_id=game_session.game_id,
                user_id=game_session.user_id,
                question_id=question.question_id,
                question_index=idx,
                # Exclude None rows for smaller space
                answer=question.submitted_answer,
                is_correct=question.is_correct,
            )
            game_qa_history_entries.append(game_qa_history)

        try:
            # Save game metadata
            await self.db.insert_data(SupabaseTable.GAME_DATA, game_data.model_dump())

            # Save all question answers in a single bulk insert
            if game_qa_history_entries:
                qa_history_data = [
                    qa_history.model_dump() for qa_history in game_qa_history_entries
                ]
                await self.db.insert_data(
                    SupabaseTable.GAME_QA_HISTORY, qa_history_data
                )

            return game_data
        except Exception as e:
            raise Exception(f"Failed to save game history: {str(e)}")

    async def _check_answers(self, questions: List[QuestionBase]) -> MarkingResult:
        """
        Checks the user's answers against the correct answers.
        Returns a list of CheckedQA objects indicating correctness.

        """
        # Outline: For each question:
        # Check the answer based on its type
        # then form into a CheckedQA object (Without question part)

        checked_questions = []
        earned_exp = 0  # Initialize earned exp
        correct_count = 0  # Count of correct answers
        try:
            assert questions, "No questions provided for checking answers"

            for question in questions:
                # 1. Checking
                match question.answer_type:
                    case AnswerType.PAIRING:
                        question = PairingCardsQuestion(**question.model_dump())

                        submitted_answer = (
                            SubmittedAnswer(
                                answer_type=AnswerType.PAIRING,
                                pairing_answers=question.pairing.submitted_pairs,
                            )
                            if question.pairing.submitted_pairs
                            else None
                        )
                        # submitted_answer = question.pairing.submitted_pairs

                    case AnswerType.MULTIPLE_CHOICE:
                        question = MultiChoiceQuestion(**question.model_dump())
                        # ensure that submitted_answers is a list
                        submitted_answer = (
                            question.mcq.submitted_answers
                            if question.mcq.submitted_answers
                            else None
                        )
                        if isinstance(submitted_answer, list):
                            submitted_answer = (
                                SubmittedAnswer(
                                    answer_type=AnswerType.MULTIPLE_CHOICE,
                                    mc_answers=submitted_answer,
                                )
                                if submitted_answer
                                else None
                            )

                    case AnswerType.WRITING:
                        question = HandwriteQuestion(**question.model_dump())
                        submitted_answer = (
                            SubmittedAnswer(
                                answer_type=AnswerType.WRITING,
                                handwriting_answer=question.writing.submitted_image,
                            )
                            if question.writing.submitted_image
                            else None
                        )

                is_correct = question.is_correct if submitted_answer else False
                correct_count += 1 if is_correct else 0
                earned_exp += question.exp if is_correct else 0

                # 2. Form into CheckedQA object
                checked_question = CheckedQA(
                    question_id=question.question_id,
                    submitted_answer=submitted_answer,
                    target_word=question.target_word,
                    is_correct=is_correct,
                )

                # 3. Append to the list
                checked_questions.append(checked_question)
        except Exception as e:
            raise Exception(f"Error checking answers: {str(e)}")

        return MarkingResult(
            checked_questions=checked_questions,
            total_score=earned_exp,  # Total score is the sum of earned exp
            remaining_hearts=max(0, 3 - (len(checked_questions) - correct_count)),
        )

    async def update_question_stats(
        self,
        answered_question_ids: List[UUIDStr],
        wrong_question_ids: List[UUIDStr],
    ):
        """
        Update the stats (wrong count, last wrong time) for the answered questions.
        Using RPC to update the stats in the database.
        """
        try:
            await self.db.rpc_query(
                SupabaseRPC.UPDATE_QUESTION_STATS,
                UpdateQuestionStatsRPC(
                    p_answered_questions=answered_question_ids,
                    p_wrong_questions=wrong_question_ids,
                ).model_dump(),
            )
        except Exception as e:
            raise Exception(f"Failed to update question stats: {str(e)}")

    async def submit_game_answers(
        self,
        questions: List[QuestionBase],
        game_id: UUIDStr,
    ) -> GameData:
        """
        Submits the game answers and processes the results.
        This includes checking answers, updating game session, saving game history and updating user experience.
        """
        # Check answers
        marked_result: MarkingResult = await self._check_answers(questions)

        # End game session
        game_session: GameSession = await self._end_game_session(game_id)

        # Update question stats and game db
        game_data: GameData = await self._save_game_history(marked_result, game_session)

        # Update user experience
        await self.user_service.update_experience(
            game_session.user_id, gained_exp=game_data.earned_exp
        )

        # Update user wrong words dictionary
        # Some words might not be past wrong words
        # Excluded words that are just not answered instead of wrong
        wrong_words = [
            question.target_word
            for question in marked_result.checked_questions
            if not question.is_correct
            and question.target_word
            and question.submitted_answer
        ]
        await self.user_service.add_wrong_words(game_session.user_id, wrong_words)

        return game_data

    async def flag_question(
        self,
        question_id: UUIDStr,
        user_id: UUIDStr,
        reason: Optional[str] = None,
        notes: Optional[str] = None,
    ) -> FlaggedQuestion:
        """
        Flags a question for manual review by inserting into the flagged_questions table.
        """
        flagged_at = get_time()
        flagged = FlaggedQuestion(
            question_id=question_id,
            user_id=user_id,
            flagged_at=flagged_at,
            reason=reason,
            notes=notes,
        )
        try:
            result = await self.db.insert_data(
                SupabaseTable.FLAGGED_QUESTIONS, flagged.model_dump(exclude_unset=True)
            )
            if isinstance(result, dict):
                result = result.get("data", [])
            if not result or "flag_id" not in result[0]:
                raise Exception("Failed to flag question, no flag_id returned")
            return FlaggedQuestion.model_validate(
                result[0]
            )  # Return the first result, which should be the inserted flag
        except Exception as e:
            logger.error(f"Error flagging question: {e}")
            raise Exception(f"Error flagging question: {str(e)}")
